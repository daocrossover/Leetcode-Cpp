// 313. Super Ugly Number
// Description:
// A super ugly number is a positive integer whose prime factors are in the array primes.
// Given an integer n and an array of integers primes, return the nth super ugly number.
// The nth super ugly number is guaranteed to fit in a 32-bit signed integer.

// Example 1:
// Input: n = 12, primes = [2,7,13,19]
// Output: 32
// Explanation: [1,2,4,7,8,13,14,16,19,26,28,32] is the sequence of the first 12 super ugly numbers given primes = [2,7,13,19].

// Example 2:
// Input: n = 1, primes = [2,3,5]
// Output: 1
// Explanation: 1 has no prime factors, therefore all of its prime factors are in the array primes = [2,3,5].

// Constraints:
// 1. 1 <= n <= 10^6
// 2. 1 <= primes.length <= 100
// 3. 2 <= primes[i] <= 1000
// 4. primes[i] is guaranteed to be a prime number.
// 5. All the values of primes are unique and sorted in ascending order.

// Solution1: using the idea from 264. Ugly Number II
// New ugly number is generated by multiplying a prime with previous generated ugly number
// Create an index array to track the index for each prime
// Time Complexity: O(kn)
// Space Complexity: O(n)

#include <vector>
using std::vector;
using std::min;

class Solution {
public:
    // TLE: redundant multiplication can be avoided
    int nthSuperUglyNumber1(int n, vector<int>& primes) {
        int len = primes.size();
        vector<int> ugly(n, 0);
        vector<int> index(len, 0);
        ugly[0] = 1;
        for (int i = 1; i < n; ++i) {
            ugly[i] = INT_MAX;
            for (int j = 0; j < len; ++j) {
                ugly[i] = min(ugly[i], primes[j] * ugly[index[j]]);
            }
            for (int j = 0; j < len; ++j) {
                while (ugly[i] == primes[j] * ugly[index[j]]) {
                    index[j]++;
                }
            }
        }
        return ugly[n - 1];
    }

    // trade-off space for speed
    // Runtime Error: INT overflow, case n = 67, primes = [2, 997]
    // need to use long long
    int nthSuperUglyNumber(int n, vector<int>& primes) {
        int len = primes.size();
        vector<int> index(len, 0);
        vector<long long> ugly(n);
        vector<long long> factor(len, 1);
        long long next = 1;
        for (int i = 0; i < n; ++i){
            ugly[i] = next;
            next = LLONG_MAX;
            for (int j = 0; j < len; ++j) {
                if (factor[j] == ugly[i]) {
                    factor[j] = primes[j] * ugly[index[j]++];
                }
                next = min(next, factor[j]);
            }
        }
        return ugly[n-1];
    }
};